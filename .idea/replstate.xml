<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1424238881669">{:repl-history {:ide [], :local [&quot;(def parse-graphql\n  (insta/parser\n    \&quot;root = &lt;WS&gt; object_name &lt;WS&gt; &lt;OPEN_ROUND&gt; &lt;WS&gt; object_id &lt;WS&gt; &lt;CLOSE_ROUND&gt; &lt;WS&gt; &lt;WS&gt; object &lt;WS&gt;\n     object = &lt;OPEN_CURLY&gt; &lt;WS&gt; field_list &lt;WS&gt; &lt;CLOSE_CURLY&gt;\n     WS =           #'\\\\s*'\n     OPEN_CURLY =   '{'\n     CLOSE_CURLY =  '}'\n     OPEN_ROUND =   '('\n     CLOSE_ROUND =   ')'\n     COMMA = ','\n     object_name =  #'\\\\w*'\n     object_id =    #'\\\\w*'\n     name =         #'\\\\w*'\n     field_name =   #'\\\\w*'\n     field_list = field &lt;WS&gt; (&lt;COMMA&gt; &lt;WS&gt; field)*\n     field = field_name &lt;WS&gt; object?\&quot;\n    :output-format :enlive))&quot; &quot;(def tree (parse-graphql graphql))\n&quot; &quot;(defn fields [tree]\n  (map #(println \&quot;1\&quot;  %) (map #(:content %) (enlive/select tree [:root :object :field_list :field]))))&quot; &quot;tree&quot; &quot;(defn fields [tree]\n  (map #(println \&quot;1\&quot;  %) (map #(:content %) (enlive/select tree [:root :object :field_list :field (enlive/right :object)]))))&quot; &quot;(defn fields [tree]\n  (map #(println \&quot;1\&quot;  %) (map #(:content %) (enlive/select tree [:root :object :field_list :field (enlive/right (enlive/but :object))]))))&quot; &quot;(defn objects [tree]\n  (map #(println \&quot;1\&quot;  %) (map #(:content %) (enlive/select tree [:root :object :field_list :field (enlive/right :object)]))))&quot; &quot;(objects tree)&quot; &quot;(defn objects [tree]\n  (enlive/select tree [:root :object :field_list :field (enlive/right :object)]))&quot; &quot;(objects\n  tree)&quot; &quot;(defn fields [tree]\n  (enlive/select tree [:root :object :field_list :field (enlive/but :object)]))\n  \n  &quot; &quot;(defn fields [tree]\n  (enlive/select tree [:root :object] [:field_list :field]))&quot; &quot;(fields\n  tree)&quot; &quot;(defn fields [tree]\n  (enlive/select tree [[:root :object] [:field_list :field]]))&quot; &quot;(defn fields [tree]\n  (enlive/select tree [:root :object :field_list :field]))&quot; &quot;(defn fields [tree]\n  (map #(println \&quot;!\&quot; %) (enlive/select tree [:root :object :field_list :field])))&quot; &quot;(defn objects [tree]\n  (enlive/select tree [:root :object :field_list :field (enlive/attr? :object)]))&quot; &quot;(objects\n  \n  tree)&quot; &quot;(def parents [pred]\n  (zip-pred (fn [loc pred]\n              (some pred (take-while identity (iterate zip/up loc))))))&quot; &quot;(use '[clojure.zip :as zip])\n&quot; &quot;(def parents\n  (zip-pred (fn [loc pred]\n              (some pred (take-while identity (iterate zip/up loc))))))&quot; &quot;(defn parents\n  (zip-pred (fn [loc pred]\n              (some pred (take-while identity (iterate zip/up loc))))))&quot; &quot;(defn parents [pred]\n  (zip-pred (fn [loc pred]\n              (some pred (take-while identity (iterate zip/up loc))))))&quot; &quot;(defn fields [tree]\n  (map #(println \&quot;!\&quot; %) (enlive/select tree [:root :object :field_list :field (enlive/but (parents (attr? :object)))])))\n&quot; &quot;(defn fields [tree]\n  (map #(println \&quot;!\&quot; %) (enlive/select tree [:root :object :field_list :field (enlive/but (enlive/right :object))])))&quot; &quot;(def parents\n  (enlive/zip-pred (fn [loc pred]\n                     (some pred (take-while identity (iterate zip/up loc))))))&quot; &quot;(defn fields [tree]\n  (map #(println \&quot;!\&quot; %) (enlive/select tree [:root :object :field_list :field (enlive/but (parents (attr? :object)))])))&quot; &quot;(fields\n  \n  tree)&quot; &quot;(def parents [pred]\n  (enlive/zip-pred (fn [loc pred]\n                     (some pred (take-while identity (iterate zip/up loc))))))&quot; &quot;(defn object-fields [tree]\n  (enlive/select tree [:root :object :field_list :field (enlive/right :object) :field]))&quot; &quot;(defn object-fields [tree]\n  (enlive/select tree [:root :object :field_list :field (enlive/right :object)]))&quot; &quot;(object-fields tree)&quot; &quot;(defn fields [tree]\n  (map #(println \&quot;!\&quot; %) (enlive/select tree [:field])))&quot; &quot;(fields tree)&quot; &quot;(def parse-graphql\n  (insta/parser\n    \&quot;root = &lt;WS&gt; object_name &lt;WS&gt; &lt;OPEN_ROUND&gt; &lt;WS&gt; object_id &lt;WS&gt; &lt;CLOSE_ROUND&gt; &lt;WS&gt; &lt;WS&gt; object &lt;WS&gt;\n     object = &lt;OPEN_CURLY&gt; &lt;WS&gt; field_list &lt;WS&gt; &lt;CLOSE_CURLY&gt;\n     WS =           #'\\\\s*'\n     OPEN_CURLY =   '{'\n     CLOSE_CURLY =  '}'\n     OPEN_ROUND =   '('\n     CLOSE_ROUND =   ')'\n     COMMA = ','\n     object_name =  #'\\\\w*'\n     object_id =    #'\\\\w*'\n     name =         #'\\\\w*'\n     field_name =   #'\\\\w*'\n     field_list = field &lt;WS&gt; (&lt;COMMA&gt; &lt;WS&gt; field)*\n     field = field_name &lt;WS&gt; object?\&quot;))&quot; &quot;(def tree2 (parse-graphql graphql))\n&quot; &quot;tree2&quot; &quot;(pp)&quot; &quot;(get-in tree2 [:root :object])&quot; &quot;(insta/transform {k v} tree2)&quot; &quot;(map tree2)&quot; &quot;(into {} tree2)&quot; &quot;(use '[clojure.walk as w])&quot; &quot;(use '[clojure.walk :as w])&quot; &quot;(w/postwalk-demo tree2)&quot; &quot;(w/prewalk-demo tree2)&quot; &quot;(defn base-object [:object_name name]\n  name)&quot; &quot;(use '[core.match :as m])\n&quot; &quot;(use '[instaparse.core :as insta])\n(use '[clojure.core.match :as m])\n(use 'clojure.zip)&quot; &quot;(def parse-graphql\n  (insta/parser\n    \&quot;root = &lt;WS&gt; object_name &lt;WS&gt; &lt;OPEN_ROUND&gt; &lt;WS&gt; object_id &lt;WS&gt; &lt;CLOSE_ROUND&gt; &lt;WS&gt; &lt;WS&gt; object &lt;WS&gt;\n     object = &lt;OPEN_CURLY&gt; &lt;WS&gt; field_list &lt;WS&gt; &lt;CLOSE_CURLY&gt;\n     WS =           #'\\\\s*'\n     OPEN_CURLY =   '{'\n     CLOSE_CURLY =  '}'\n     OPEN_ROUND =   '('\n     CLOSE_ROUND =   ')'\n     COMMA = ','\n     object_name =  #'\\\\w*'\n     object_id =    #'\\\\w*'\n     name =         #'\\\\w*'\n     field_name =   #'\\\\w*'\n     field_list = field &lt;WS&gt; (&lt;COMMA&gt; &lt;WS&gt; field)*\n     field = field_name &lt;WS&gt; object?\&quot;))\n\n(def graphql \&quot;\n       User (234234) {\n           one {\n               sub1,\n               sub2\n           },\n           two,\n           three,\n           four\n       }\n   \&quot;)\n\n(def tree (parse-graphql graphql))&quot; &quot;(def zp (zipper vector? seq (fn [_ c] c) tree))\n&quot; &quot;(defn is-field [node]\n  (and (vector? node) (keyword? (first node)) (= (first node) :field)))\n\n(defn create-datalog [loc]\n  (let [curr-node (node loc)\n        field-parent (-&gt; loc up up up node)\n        is-root (= field-parent (root loc))\n        field-name (-&gt; curr-node second second)\n        base-class (-&gt; field-parent second second)]\n    (println curr-node \&quot;PARENT\&quot; field-parent)\n    (if is-root\n      field-name\n      [base-class field-name])))\n\n(defn walk-zip [z]\n  (loop [loc z\n         results []]\n    (println \&quot;RESULTS\&quot; results)\n    (if (end? loc)\n      results\n      (if (is-field (node loc))\n        (recur (next loc) (conj results (create-datalog loc)))\n        (recur (next loc) results)))))\n\n(walk-zip zp)&quot; &quot;(defn object-name [z]\n  (node (-&gt; z down)))&quot; &quot;(defn object-name [z]\n  (node (-&gt; z down down)))\n&quot; &quot;(object-name zp\n             )&quot; &quot;(defn object-name [z]\n  (-&gt; z down right))&quot; &quot;(defn object-name [z]\n  (node (-&gt; z down right)))&quot; &quot;(defn object-name [z]\n  (second (node (-&gt; z down right))))&quot; &quot;(object-name zp)&quot; &quot;(partition vector? (walk-zip zp))&quot; &quot;(partition vector? '[one [one sub1] [one sub2] two three four])&quot; &quot;(partition-by vector? '[one [one sub1] [one sub2] two three four])&quot; &quot;(partition-by vector? (walk-zip zp))&quot; &quot;(partition-all vector? (walk-zip zp))&quot; &quot;(group-by vector? (walk-zip zp))&quot; &quot;(defn get-attributes [z]\n  (false (group-by vector? (walk-zip z))))&quot; &quot;(defn get-attributes [z]\n  (get (group-by vector? (walk-zip z)) false))&quot; &quot;(get-attributes zp)&quot; &quot;(defn get-metadata [z]\n  [(object-name z) (get-attributes z)])&quot; &quot;(get-metadata zp)&quot; &quot;(use 'graphql-parser.core)&quot; &quot;(def graphql \&quot;\n       User (234234) {\n           one {\n               sub1,\n               sub2\n           },\n           two,\n           three,\n           four\n       }\n   \&quot;)&quot; &quot;(def Artist\n  {:gid :artist/gid\n   :name :artist/name\n   :sortName :artist/sortName\n   :type :artist/type\n   :gender :artist/gender\n   :country :artist/country\n   :startYear :artist/startYear})\n\n(defn graph-ql [root attributes]\n  (let [metadata (eval (symbol root))\n        schema (select-keys metadata (map keyword attributes))\n        attrs (map val schema)]\n    (print attrs)))&quot; &quot;(graph-ql \&quot;Artist\&quot; [\&quot;gid\&quot; \&quot;name\&quot;])&quot; &quot;(def graphql \&quot;\n       Artist (234234) {\n           name,\n           type,\n           gender,\n           country\n       }\n   \&quot;)&quot; &quot;(defn ql-&gt;pull [root attributes]\n  (let [metadata (eval (symbol root))\n        schema (select-keys metadata (map keyword attributes))\n        attrs (map val schema)]\n    (print attrs)))&quot; &quot;(ql-&gt;pull (graphql-&gt;datalog graphql))&quot; &quot;(ql-&gt;pull (first (graphql-&gt;datalog graphql)))&quot; &quot;(graphql-&gt;datalog graphql)&quot; &quot;(defn create-pull [graphql]\n  (let [datalog (graphql-&gt;datalog graphql)]\n    (ql-&gt;pull (first datalog) (second datalog))))&quot; &quot;(def graphql \&quot;\n       Artist (17592186046982) {\n           name,\n           type,\n           gender,\n           country\n       }\n   \&quot;)&quot; &quot;\n(defn create-pull [graphql]\n  (let [datalog (graphql-&gt;datalog graphql)]\n    (ql-&gt;pull (first datalog) (second datalog))))\n\n(defn graphql-query [graphql]\n  (let [pull (create-pull graphql)\n        db (-&gt; uri d/connect d/db)]\n    (d/pull 17592186046982 pull db)))&quot; &quot;(defn graphql-query [graphql]\n  (let [pull (create-pull graphql)\n        db (-&gt; uri d/connect d/db)]\n    (d/pull db 17592186046982 pull)))&quot; &quot;(use 'clojure.stacktrace)&quot; &quot;(e)&quot; &quot;(-&gt; uri d/connect d/db)&quot; &quot;()&quot; &quot;(d/pull (-&gt; uri d/connect d/db) '[*] 17592186046982)&quot; &quot;(d/pull (-&gt; uri d/connect d/db) '[*] 17592186050305)&quot; &quot;(use '[datomic.api :as d])&quot; &quot;(d/pull (-&gt; uri d/connect d/db) '[*] 17592186050305\n        )&quot; &quot;(create-pull graphql)&quot; &quot;(Integer/parseInt \&quot;17592186050305\&quot;)&quot; &quot;(read-string \&quot;17592186050305\&quot;)&quot; &quot;(def graphql \&quot;\n       Artist (17592186050305) {\n           name,\n           sortName,\n           gender,\n           country,\n           gid,\n           type\n       }\n   \&quot;)&quot; &quot;(def graphql2 \&quot;\n       Artist (17592186050305) {\n           name,\n           sortName,\n           gender,\n           country,\n           gid,\n           type\n       }\n   \&quot;)&quot; &quot;(graphql-query graphql2)&quot; &quot;(def graphql1 \&quot;\n       User (234234) {\n           one {\n               sub1,\n               sub2\n           },\n           two,\n           three,\n           four\n       }\n   \&quot;)&quot; &quot;(graphql-query graphql1)&quot; &quot;(use 'graphql-parser.example)&quot; &quot;(graphql-query graphql)&quot;], :remote []}}</component>
</project>