<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1424223798221">{:repl-history {:ide [], :local [&quot;(def parse-graphql\n  (insta/parser\n    \&quot;root = WS object_name WS OPEN_ROUND WS object_id WS CLOSE_ROUND WS WS object WS\n     object = OPEN_CURLY WS field_list WS CLOSE_CURLY\n     WS =           #'\\\\s*'\n     OPEN_CURLY =   '{'\n     CLOSE_CURLY =  '}'\n     OPEN_ROUND =   '('\n     CLOSE_ROUND =   ')'\n     COMMA = ','\n     object_name =  #'[A-Z0-9]*i'\n     object_id =    #'[A-Z0-9]*i'\n     name =         #'[A-Z0-9]*i'\n     field_name =   #'[A-Z0-9]*i'\n     field_list = field WS (COMMA WS field)*\n     field = field_name WS optional_object\n     optional_object = object?\&quot;))&quot; &quot;(def graphql \&quot;\n       User (234234) {\n           one {\n               sub1,\n               sub2\n           },\n           two,\n           three,\n           four\n       }\n   \&quot;)\n&quot; &quot;(def parse-graphql\n  (insta/parser\n    \&quot;root = WS object_name WS OPEN_ROUND WS object_id WS CLOSE_ROUND WS WS object WS\n     object = OPEN_CURLY WS field_list WS CLOSE_CURLY\n     WS =           #'\\\\s*'\n     OPEN_CURLY =   '{'\n     CLOSE_CURLY =  '}'\n     OPEN_ROUND =   '('\n     CLOSE_ROUND =   ')'\n     COMMA = ','\n     object_name =  #'\\\\w*'\n     object_id =    #'[A-Z0-9]*i'\n     name =         #'[A-Z0-9]*i'\n     field_name =   #'[A-Z0-9]*i'\n     field_list = field WS (COMMA WS field)*\n     field = field_name WS optional_object\n     optional_object = object?\&quot;))&quot; &quot;(def parse-graphql\n  (insta/parser\n    \&quot;root = WS object_name WS OPEN_ROUND WS object_id WS CLOSE_ROUND WS WS object WS\n     object = OPEN_CURLY WS field_list WS CLOSE_CURLY\n     WS =           #'\\\\w*'\n     OPEN_CURLY =   '{'\n     CLOSE_CURLY =  '}'\n     OPEN_ROUND =   '('\n     CLOSE_ROUND =   ')'\n     COMMA = ','\n     object_name =  #'\\\\w*'\n     object_id =    #'[A-Z0-9]*i'\n     name =         #'[A-Z0-9]*i'\n     field_name =   #'[A-Z0-9]*i'\n     field_list = field WS (COMMA WS field)*\n     field = field_name WS optional_object\n     optional_object = object?\&quot;))&quot; &quot;(def parse-graphql\n  (insta/parser\n    \&quot;root = WS object_name WS OPEN_ROUND WS object_id WS CLOSE_ROUND WS WS object WS\n     object = OPEN_CURLY WS field_list WS CLOSE_CURLY\n     WS =           #'\\\\s*'\n     OPEN_CURLY =   '{'\n     CLOSE_CURLY =  '}'\n     OPEN_ROUND =   '('\n     CLOSE_ROUND =   ')'\n     COMMA = ','\n     object_name =  #'\\\\w*'\n     object_id =    #'\\\\w*'\n     name =         #'\\\\w*'\n     field_name =   #'\\\\w*'\n     field_list = field WS (COMMA WS field)*\n     field = field_name WS optional_object\n     optional_object = object?\&quot;))&quot; &quot;(parse-graphql graphql)&quot; &quot;(filter)&quot; &quot;(filter #(:WS %) tree)&quot; &quot;(filter #(println %) tree)&quot; &quot;(postwalk-demo tree)&quot; &quot;(clojure.walk/postwalk-demo tree)&quot; &quot;(def parse-graphql\n  (insta/parser\n    \&quot;root = &lt;WS&gt; object_name &lt;WS&gt; &lt;OPEN_ROUND&gt; &lt;WS&gt; object_id &lt;WS&gt; &lt;CLOSE_ROUND&gt; &lt;WS&gt; &lt;WS&gt; object &lt;WS&gt;\n     object = OPEN_CURLY WS field_list WS CLOSE_CURLY\n     WS =           #'\\\\s*'\n     OPEN_CURLY =   '{'\n     CLOSE_CURLY =  '}'\n     OPEN_ROUND =   '('\n     CLOSE_ROUND =   ')'\n     COMMA = ','\n     object_name =  #'\\\\w*'\n     object_id =    #'\\\\w*'\n     name =         #'\\\\w*'\n     field_name =   #'\\\\w*'\n     field_list = field &lt;WS&gt; (&lt;COMMA&gt; &lt;WS&gt; field)*\n     field = field_name &lt;WS&gt; optional_object\n     optional_object = object?\&quot;))&quot; &quot;(def parse-graphql\n  (insta/parser\n    \&quot;root = &lt;WS&gt; object_name &lt;WS&gt; &lt;OPEN_ROUND&gt; &lt;WS&gt; object_id &lt;WS&gt; &lt;CLOSE_ROUND&gt; &lt;WS&gt; &lt;WS&gt; object &lt;WS&gt;\n     object = &lt;OPEN_CURLY&gt; &lt;WS&gt; field_list &lt;WS&gt; &lt;CLOSE_CURLY&gt;\n     WS =           #'\\\\s*'\n     OPEN_CURLY =   '{'\n     CLOSE_CURLY =  '}'\n     OPEN_ROUND =   '('\n     CLOSE_ROUND =   ')'\n     COMMA = ','\n     object_name =  #'\\\\w*'\n     object_id =    #'\\\\w*'\n     name =         #'\\\\w*'\n     field_name =   #'\\\\w*'\n     field_list = field &lt;WS&gt; (&lt;COMMA&gt; &lt;WS&gt; field)*\n     field = field_name &lt;WS&gt; optional_object\n     optional_object = object?\&quot;))&quot; &quot;(def tree (parse-graphql graphql))&quot; &quot;(insta/transform\n  {:object_id str}\n  tree)&quot; &quot;(def parse-graphql\n  (insta/parser\n    \&quot;root = &lt;WS&gt; object_name &lt;WS&gt; &lt;OPEN_ROUND&gt; &lt;WS&gt; object_id &lt;WS&gt; &lt;CLOSE_ROUND&gt; &lt;WS&gt; &lt;WS&gt; object &lt;WS&gt;\n     object = &lt;OPEN_CURLY&gt; &lt;WS&gt; field_list &lt;WS&gt; &lt;CLOSE_CURLY&gt;\n     WS =           #'\\\\s*'\n     OPEN_CURLY =   '{'\n     CLOSE_CURLY =  '}'\n     OPEN_ROUND =   '('\n     CLOSE_ROUND =   ')'\n     COMMA = ','\n     object_name =  #'\\\\w*'\n     object_id =    #'\\\\w*'\n     name =         #'\\\\w*'\n     field_name =   #'\\\\w*'\n     field_list = field &lt;WS&gt; (&lt;COMMA&gt; &lt;WS&gt; field)*\n     field = field_name &lt;WS&gt; optional_object\n     optional_object = object?\&quot;\n    :output-format :enlive))&quot; &quot;(use '[instaparse.core :as insta])\n&quot; &quot;(use '[net.cgrand.enlive-html :as enlive])\n&quot; &quot;\n(def parse-graphql\n  (insta/parser\n    \&quot;root = &lt;WS&gt; object_name &lt;WS&gt; &lt;OPEN_ROUND&gt; &lt;WS&gt; object_id &lt;WS&gt; &lt;CLOSE_ROUND&gt; &lt;WS&gt; &lt;WS&gt; object &lt;WS&gt;\n     object = &lt;OPEN_CURLY&gt; &lt;WS&gt; field_list &lt;WS&gt; &lt;CLOSE_CURLY&gt;\n     WS =           #'\\\\s*'\n     OPEN_CURLY =   '{'\n     CLOSE_CURLY =  '}'\n     OPEN_ROUND =   '('\n     CLOSE_ROUND =   ')'\n     COMMA = ','\n     object_name =  #'\\\\w*'\n     object_id =    #'\\\\w*'\n     name =         #'\\\\w*'\n     field_name =   #'\\\\w*'\n     field_list = field &lt;WS&gt; (&lt;COMMA&gt; &lt;WS&gt; field)*\n     field = field_name &lt;WS&gt; optional_object\n     optional_object = object?\&quot;\n    :output-format :enlive))&quot; &quot;(def graphql \&quot;\n       User (234234) {\n           one {\n               sub1,\n               sub2\n           },\n           two,\n           three,\n           four\n       }\n   \&quot;)&quot; &quot;(enlive/at tree [:root])&quot; &quot;(enlive/at tree [:object_id])&quot; &quot;(enlive/at tree [:root :object_id])&quot; &quot;(enlive/select tree [:root :object_id])&quot; &quot;(enlive/select tree [:object_id])&quot; &quot;(enlive/select tree [:field])&quot; &quot;(defn base-object [tree]\n  (:content (enlive/select tree [:object_name])))&quot; &quot;(defn base-object [tree]\n  (enlive/select tree [:object_name]))&quot; &quot;(defn base-object [tree]\n  (first (enlive/select tree [:object_name])))&quot; &quot;(defn base-object [tree]\n  (:content (first (enlive/select tree [:root :object_name]))))&quot; &quot;(base-object tree)&quot; &quot;(defn fields [tree]\n  (map :content (enlive/select tree [:root :field])))&quot; &quot;(defn fields [tree]\n  (enlive/select tree [:root :field]))&quot; &quot;(defn fields [tree]\n  (enlive/select tree [:root :object :field_list]))&quot; &quot;(defn fields [tree]\n  (enlive/select tree [:root :object :field_list :field :field_name]))&quot; &quot;(defn fields [tree]\n  (enlive/select tree [:root :object :field_list :field ]))&quot; &quot;(defn fields [tree]\n  (enlive/select tree [:root :object :field_list :field :content]))&quot; &quot;(defn fields [tree]\n  (enlive/select tree [:root :object :field_list :field :field]))&quot; &quot;(pp tree)&quot; &quot;(pp\n  )&quot; &quot;(tree)&quot; &quot;pp&quot; &quot;(defn fields [tree]\n  (map #(:content %) (enlive/select tree [:root :object :field_list :field])))&quot; &quot;(defn fields [tree]\n  (filter #(== (:tag %) :field_name) (map #(:content %) (enlive/select tree [:root :object :field_list :field]))))&quot; &quot;(defn fields [tree]\n  (map #(println %) (map #(:content %) (enlive/select tree [:root :object :field_list :field]))))&quot; &quot;(defn fields [tree]\n  (map #(println (:tag (first %))) (map #(:content %) (enlive/select tree [:root :object :field_list :field]))))&quot; &quot;(defn fields [tree]\n  (filter #(== (:tag (first %)) :field_name) (map #(:content %) (enlive/select tree [:root :object :field_list :field]))))&quot; &quot;(defn fields [tree]\n  (map #(println (:tag (first %)) :field_name) (map #(:content %) (enlive/select tree [:root :object :field_list :field]))))&quot; &quot;(defn fields [tree]\n  (map #(println (:tag %)) (map #(:content %) (enlive/select tree [:root :object :field_list :field]))))&quot; &quot;(defn fields [tree]\n  (map #(println  %) (map #(:content %) (enlive/select tree [:root :object :field_list :field]))))&quot; &quot;(defn fields [tree]\n  (map #(println \&quot;1\&quot;  %) (map #(:content %) (enlive/select tree [:root :object :field_list :field]))))\n&quot; &quot;(defn fields [tree]\n  (map #(println \&quot;1\&quot;  %) (map #(:content %) (enlive/select tree [:root :object :field_list :field (enlive/but :optional_object)]))))&quot; &quot;(defn fields [tree]\n  (map #(println \&quot;1\&quot;  %) (map #(:content %) (enlive/select tree [:root :object :field_list :field (enlive/but :object)]))))&quot; &quot;(def parse-graphql\n  (insta/parser\n    \&quot;root = &lt;WS&gt; object_name &lt;WS&gt; &lt;OPEN_ROUND&gt; &lt;WS&gt; object_id &lt;WS&gt; &lt;CLOSE_ROUND&gt; &lt;WS&gt; &lt;WS&gt; object &lt;WS&gt;\n     object = &lt;OPEN_CURLY&gt; &lt;WS&gt; field_list &lt;WS&gt; &lt;CLOSE_CURLY&gt;\n     WS =           #'\\\\s*'\n     OPEN_CURLY =   '{'\n     CLOSE_CURLY =  '}'\n     OPEN_ROUND =   '('\n     CLOSE_ROUND =   ')'\n     COMMA = ','\n     object_name =  #'\\\\w*'\n     object_id =    #'\\\\w*'\n     name =         #'\\\\w*'\n     field_name =   #'\\\\w*'\n     field_list = field &lt;WS&gt; (&lt;COMMA&gt; &lt;WS&gt; field)*\n     field = field_name &lt;WS&gt; object?\&quot;\n    :output-format :enlive))&quot; &quot;(def tree (parse-graphql graphql))\n&quot; &quot;(defn fields [tree]\n  (map #(println \&quot;1\&quot;  %) (map #(:content %) (enlive/select tree [:root :object :field_list :field]))))&quot; &quot;tree&quot; &quot;(defn fields [tree]\n  (map #(println \&quot;1\&quot;  %) (map #(:content %) (enlive/select tree [:root :object :field_list :field (enlive/right :object)]))))&quot; &quot;(defn fields [tree]\n  (map #(println \&quot;1\&quot;  %) (map #(:content %) (enlive/select tree [:root :object :field_list :field (enlive/right (enlive/but :object))]))))&quot; &quot;(defn objects [tree]\n  (map #(println \&quot;1\&quot;  %) (map #(:content %) (enlive/select tree [:root :object :field_list :field (enlive/right :object)]))))&quot; &quot;(objects tree)&quot; &quot;(defn objects [tree]\n  (enlive/select tree [:root :object :field_list :field (enlive/right :object)]))&quot; &quot;(objects\n  tree)&quot; &quot;(defn fields [tree]\n  (enlive/select tree [:root :object :field_list :field (enlive/but :object)]))\n  \n  &quot; &quot;(defn fields [tree]\n  (enlive/select tree [:root :object] [:field_list :field]))&quot; &quot;(fields\n  tree)&quot; &quot;(defn fields [tree]\n  (enlive/select tree [[:root :object] [:field_list :field]]))&quot; &quot;(defn fields [tree]\n  (enlive/select tree [:root :object :field_list :field]))&quot; &quot;(defn fields [tree]\n  (map #(println \&quot;!\&quot; %) (enlive/select tree [:root :object :field_list :field])))&quot; &quot;(defn objects [tree]\n  (enlive/select tree [:root :object :field_list :field (enlive/attr? :object)]))&quot; &quot;(objects\n  \n  tree)&quot; &quot;(def parents [pred]\n  (zip-pred (fn [loc pred]\n              (some pred (take-while identity (iterate zip/up loc))))))&quot; &quot;(use '[clojure.zip :as zip])\n&quot; &quot;(def parents\n  (zip-pred (fn [loc pred]\n              (some pred (take-while identity (iterate zip/up loc))))))&quot; &quot;(defn parents\n  (zip-pred (fn [loc pred]\n              (some pred (take-while identity (iterate zip/up loc))))))&quot; &quot;(defn parents [pred]\n  (zip-pred (fn [loc pred]\n              (some pred (take-while identity (iterate zip/up loc))))))&quot; &quot;(defn fields [tree]\n  (map #(println \&quot;!\&quot; %) (enlive/select tree [:root :object :field_list :field (enlive/but (parents (attr? :object)))])))\n&quot; &quot;(defn fields [tree]\n  (map #(println \&quot;!\&quot; %) (enlive/select tree [:root :object :field_list :field (enlive/but (enlive/right :object))])))&quot; &quot;(def parents\n  (enlive/zip-pred (fn [loc pred]\n                     (some pred (take-while identity (iterate zip/up loc))))))&quot; &quot;(defn fields [tree]\n  (map #(println \&quot;!\&quot; %) (enlive/select tree [:root :object :field_list :field (enlive/but (parents (attr? :object)))])))&quot; &quot;(fields\n  \n  tree)&quot; &quot;(def parents [pred]\n  (enlive/zip-pred (fn [loc pred]\n                     (some pred (take-while identity (iterate zip/up loc))))))&quot; &quot;(defn object-fields [tree]\n  (enlive/select tree [:root :object :field_list :field (enlive/right :object) :field]))&quot; &quot;(defn object-fields [tree]\n  (enlive/select tree [:root :object :field_list :field (enlive/right :object)]))&quot; &quot;(object-fields tree)&quot; &quot;(defn fields [tree]\n  (map #(println \&quot;!\&quot; %) (enlive/select tree [:field])))&quot; &quot;(fields tree)&quot; &quot;(def parse-graphql\n  (insta/parser\n    \&quot;root = &lt;WS&gt; object_name &lt;WS&gt; &lt;OPEN_ROUND&gt; &lt;WS&gt; object_id &lt;WS&gt; &lt;CLOSE_ROUND&gt; &lt;WS&gt; &lt;WS&gt; object &lt;WS&gt;\n     object = &lt;OPEN_CURLY&gt; &lt;WS&gt; field_list &lt;WS&gt; &lt;CLOSE_CURLY&gt;\n     WS =           #'\\\\s*'\n     OPEN_CURLY =   '{'\n     CLOSE_CURLY =  '}'\n     OPEN_ROUND =   '('\n     CLOSE_ROUND =   ')'\n     COMMA = ','\n     object_name =  #'\\\\w*'\n     object_id =    #'\\\\w*'\n     name =         #'\\\\w*'\n     field_name =   #'\\\\w*'\n     field_list = field &lt;WS&gt; (&lt;COMMA&gt; &lt;WS&gt; field)*\n     field = field_name &lt;WS&gt; object?\&quot;))&quot; &quot;(def tree2 (parse-graphql graphql))\n&quot; &quot;tree2&quot; &quot;(pp)&quot; &quot;(get-in tree2 [:root :object])&quot; &quot;(insta/transform {k v} tree2)&quot; &quot;(map tree2)&quot; &quot;(into {} tree2)&quot; &quot;(use '[clojure.walk as w])&quot; &quot;(use '[clojure.walk :as w])&quot; &quot;(w/postwalk-demo tree2)&quot; &quot;(w/prewalk-demo tree2)&quot; &quot;(defn base-object [:object_name name]\n  name)&quot; &quot;(use '[core.match :as m])\n&quot;], :remote []}}</component>
</project>